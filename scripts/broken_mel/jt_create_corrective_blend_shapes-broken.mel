
/***************************************************************************************************

# JT_createCorrectiveBlendShapes.mel

# www.jonathantopf.com 2012

# helps create corective blendshapes on a mesh driven by a bone
    
# Copyright (c) 2012 Jonathan Topf

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.


***************************************************************************************************/


// define function to removes spaces from a string and replace them with "_"

proc string removeSpaces(string $str){

	string $str_token[];

	tokenize $str " " $str_token; // splits original string into many smaller strngs at each white space

	if (size($str_token) > 1) {

    	int $i = 0;
    	$str = "";
    	while (size($str_token) > $i){
        	$str += $str_token[$i];
        	
        	if (size($str_token) > ($i+1)) { // stops an extra "_" being added at the end of the string
            	$str += "_";
        	}
        	
        	$i++;
    	}

	}

return $str;

}

// show UI -----------------------------------------------------------------------------------------

global proc JT_createCorrectiveBlendShapes() {
	if (getApplicationVersionAsFloat() >= 2011){
	
		string $scriptsDirectory = `internalVar -usd`;	
		string $JT_createCorrectiveBlendShapes_window = `loadUI -uiFile ($scriptsDirectory+"JT_createCorrectiveBlendShapes_Window.ui")`;
		showWindow $JT_createCorrectiveBlendShapes_window;
	
	} else {
	
	error "you are using a verion of maya that is too old";
	
	}

}

// procedure to mirror an objct with history -----------------------------------------------------------------------------------------

global proc string mirrorVerts(string $R_name){
    
    string $L_name = `substitute "R_" $R_name "L_"`;
    
    string $L_passthrough_name = $L_name + "_passthrough";
    
    select -r $R_name;
    
    float $bounding_box[] = `xform -q -boundingBox`;
    
    float $width = $bounding_box[3] - $bounding_box[0];
    
    duplicate -n $L_passthrough_name;
    
    select -r $R_name;
    
    duplicate -n $L_name;
    
    select -r $R_name $L_passthrough_name;
    
    string $new_blendshape = $R_name + "_passthrough_blendshape";
    
    blendShape -n $new_blendshape;
    
    string $blendshape_attribute = $new_blendshape + "." + $R_name;
    
    setAttr $blendshape_attribute 1;
        
    string $L_passthrough_xscale_param = $L_passthrough_name + ".scaleX";
    
    setAttr $L_passthrough_xscale_param -1;
    
    select -r $L_name $L_passthrough_name;
    
    CreateWrap; 
    
    // CreateWrap creates a 'base' transform that the influence object is attached to
    string $passthrough_base = $L_passthrough_name + "Base";
    
    //parent hide passthrough object and parent it to $L_name
    select -r $L_name $L_passthrough_name;

    parentConstraint -mo -weight 1;

    select -r $L_name $passthrough_base;
    
    parentConstraint -mo -weight 1;
    
    select -r $L_passthrough_name; 
    
    hide;

    select -r $L_name;

    return $L_name;
        
}

// procedure to create a single corrective blend shapes -----------------------------------------------------------------------------------
proc JT_createCorrectiveBlendShapee_Create (string $bone_axis, string $mesh, string $name, float $start, float $end, string $blend_shape_node, int $mirror){

	if ($mirror){
		$name = "R_" + $name;
	}

	duplicate -name $name $mesh;
	select -r $name $mesh;
	
	// find out how many blendshapes there are already so we can later set the correct index for the new blendhape
	string $num_blendshapes[] = `blendShape -q -t $blend_shape_node`;

	blendShape -e  -t $mesh (size($num_blendshapes)+1) $name 1 $blend_shape_node;

	// set start driven key
	setAttr $bone_axis $start;
	setAttr ($blend_shape_node+"."+$name) 0;
	setDrivenKeyframe -currentDriver $bone_axis ($blend_shape_node+"."+$name);

	// set end driven key
	setAttr $bone_axis $end;
	setAttr ($blend_shape_node+"."+$name) 1;
	setDrivenKeyframe -currentDriver $bone_axis ($blend_shape_node+"."+$name);

	// reset joint rotation
	setAttr $bone_axis 0;

	if ($mirror) {
		string $bone_axis_mirror = `substitute "R_" $bone_axis "L_"`;

		string $mirrored_mesh_name = `mirrorVerts($name)`;

		select -r $mirrored_mesh_name $mesh;
		// find out how many blendshapes there are already so we can later set the correct index for the new blendhape
		string $num_blendshapes[] = `blendShape -q -t $blend_shape_node`;

		blendShape -e  -t $mesh (size($num_blendshapes)+1) $mirrored_mesh_name 1 $blend_shape_node;

		// set start driven key
		setAttr $bone_axis_mirror $start;
		setAttr ($blend_shape_node+"."+$mirrored_mesh_name) 0;
		setDrivenKeyframe -currentDriver $bone_axis_mirror ($blend_shape_node+"."+$mirrored_mesh_name);

		// set end driven key
		setAttr $bone_axis_mirror $end;
		setAttr ($blend_shape_node+"."+$mirrored_mesh_name) 1;
		setDrivenKeyframe -currentDriver $bone_axis_mirror ($blend_shape_node+"."+$mirrored_mesh_name);

		// reset joint rotation
		setAttr $bone_axis_mirror 0;

		select -r $mirrored_mesh_name;

		float $bounding_box[] = `xform -q -boundingBox`;
    
    	float $width = $bounding_box[3] - $bounding_box[0];

    	move -x -r (0 - ($width * 1.2));

		select -r $mirrored_mesh_name $name;

		parent;


	}

	select -r $name;

}


// create corrective blend shapes -----------------------------------------------------------------------------------
global proc JT_createCorrectiveBlendShapes_Create (){

	int $x_low_create = `checkBox -q -value JT_createCorrectiveBlendShapes_XLow_Check`;	
	float $x_low = `textField -q -text JT_createCorrectiveBlendShapes_XLow`;
	int $x_high_create = `checkBox -q -value JT_createCorrectiveBlendShapes_XHigh_Check`;
	float $x_high = `textField -q -text JT_createCorrectiveBlendShapes_XHigh`;

	int $y_low_create = `checkBox -q -value JT_createCorrectiveBlendShapes_YLow_Check`;	
	float $y_low = `textField -q -text JT_createCorrectiveBlendShapes_YLow`;
	int $y_high_create = `checkBox -q -value JT_createCorrectiveBlendShapes_YHigh_Check`;	
	float $y_high = `textField -q -text JT_createCorrectiveBlendShapes_YHigh`;

	int $z_low_create = `checkBox -q -value JT_createCorrectiveBlendShapes_ZLow_Check`;	
	float $z_low = `textField -q -text JT_createCorrectiveBlendShapes_ZLow`;
	int $z_high_create = `checkBox -q -value JT_createCorrectiveBlendShapes_ZHigh_Check`;	
	float $z_high = `textField -q -text JT_createCorrectiveBlendShapes_ZHigh`;

	int $mirror = `checkBox -q -value JT_createCorrectiveBlendShapes_mirror`;

	string $blend_shape_name = `textField -q -text JT_createCorrectiveBlendShapes_BlendShape`;

	// get list of selected objects
	string $selected[] = `ls -sl`;

	select $selected[1];
	float $bounding_box[] = `xform -q -boundingBox`;
	float $x_length = $bounding_box[3] - $bounding_box[0];
	float $y_length = $bounding_box[4] - $bounding_box[1];


	// if no blendshape exists create a blank one
	if ($blend_shape_name == ""){
		select -r $selected[1];
		string $blendshape[] = `blendShape`;
		$blend_shape_name = $blendshape[0];
	}


	int $offset_count = 0;
	float $x_offset_mult = 1.5;
	float $y_offset_mult = 1.5;

	// X -------
	if ($x_low_create){
		JT_createCorrectiveBlendShapee_Create(($selected[0]+".rotateX"), $selected[1], ($selected[1]+"_correct_x_low"), 0, $x_low, $blend_shape_name, $mirror);
		move -x -r ((0 - $x_length) * $x_offset_mult);
		move -y -r (($y_length * $y_offset_mult) * $offset_count);
		$offset_count += 1;
	}

	if ($x_high_create){
		JT_createCorrectiveBlendShapee_Create(($selected[0]+".rotateX"), $selected[1], ($selected[1]+"_correct_x_high"), 0, $x_high, $blend_shape_name, $mirror);
		move -x -r ((0 - $x_length) * $x_offset_mult);
		move -y -r (($y_length * $y_offset_mult) * $offset_count);
		$offset_count += 1;
	}

	// Y -------
	if ($y_low_create){
		JT_createCorrectiveBlendShapee_Create(($selected[0]+".rotateY"), $selected[1], ($selected[1]+"_correct_y_low"), 0, $y_low, $blend_shape_name, $mirror);
		move -x -r ((0 - $x_length) * $x_offset_mult);
		move -y -r (($y_length * $y_offset_mult) * $offset_count);
		$offset_count += 1;
	}

	if ($y_high_create){
		JT_createCorrectiveBlendShapee_Create(($selected[0]+".rotateY"), $selected[1], ($selected[1]+"_correct_y_high"), 0, $y_high, $blend_shape_name, $mirror);
		move -x -r ((0 - $x_length) * $x_offset_mult);
		move -y -r (($y_length * $y_offset_mult) * $offset_count);
		$offset_count += 1;
	}

	// Z -------
	if ($z_low_create){
		JT_createCorrectiveBlendShapee_Create(($selected[0]+".rotateZ"), $selected[1], ($selected[1]+"_correct_z_low"), 0, $z_low, $blend_shape_name, $mirror);
		move -x -r ((0 - $x_length) * $x_offset_mult);
		move -y -r (($y_length * $y_offset_mult) * $offset_count);
		$offset_count += 1;
	}

	if ($z_high_create){
		JT_createCorrectiveBlendShapee_Create(($selected[0]+".rotateZ"), $selected[1], ($selected[1]+"_correct_z_high"), 0, $z_high, $blend_shape_name, $mirror);
		move -x -r ((0 - $x_length) * $x_offset_mult);
		move -y -r (($y_length * $y_offset_mult) * $offset_count);
		$offset_count += 1;
	}

	deleteUI "JT_createCorrectiveBlendShapes";



}













